# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01-discography.ipynb (unless otherwise specified).

__all__ = ['initialise_spotify_client', 'setup_client_scopes', 'try_accept', 'load_artist_discog',
           'extract_album_dates', 'name_2_album_meta', 'check_release_date_consistency',
           'df_album_dates_to_spotify_meta', 'extract_all_songs_in_albums', 'retrieve_track_analysis']

# Cell
import pandas as pd
import numpy as np

import FEAutils as hlp
import matplotlib.pyplot as plt
import seaborn as sns

import spotipy
from spotipy.oauth2 import SpotifyClientCredentials

import os
import re
import json
import html
import requests
import functools

from warnings import warn
from ipypb import track

# Cell
def initialise_spotify_client():
    client_id = os.getenv('SPOTIFY_ID')
    client_secret = os.getenv('SPOTIFY_SECRET')

    client_credentials_manager = SpotifyClientCredentials(client_id=client_id, client_secret=client_secret)
    sp = spotipy.Spotify(client_credentials_manager=client_credentials_manager)

    return sp

# Cell
def setup_client_scopes():
    client_id = os.getenv('SPOTIFY_ID')

    spotify_auth_url = 'https://accounts.spotify.com/authorize'
    scopes = ['user-read-private', 'user-modify-playback-state', 'user-read-currently-playing', 'user-read-recently-played', 'user-read-playback-state', 'playlist-read-collaborative']

    query_params = {
        'client_id' : client_id,
        'response_type' : 'code',
        'redirect_uri' : 'http://osuked.com',
        'scope' : ' '.join(scopes)
    }

    r = requests.get(spotify_auth_url, params=query_params)

    return r

# Cell
def try_accept(exception=np.nan):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            try:
                return func(*args, **kwargs)
            except:
                return exception
        return wrapper
    return decorator

# Cell
def load_artist_discog(artist):
    wiki_discog_url = f"https://en.wikipedia.org/wiki/{artist.replace(' ', '_')}_discography"

    tables = pd.read_html(wiki_discog_url)
    df_discog = tables[1]

    if isinstance(df_discog.columns, pd.MultiIndex):
        df_discog.columns = df_discog.columns.get_level_values(0)

    df_discog = df_discog.drop(df_discog.index[df_discog['Title'].str.contains('"â€”" denotes')])

    return df_discog

# Cell
def extract_album_dates(df_discog):
    cols_2_keep = ['Title', 'Album details']

    df_album_dates = df_discog[cols_2_keep].copy()
    df_album_dates.columns = cols_2_keep

    s_dt = (df_album_dates
            ['Album details']
            .str[10:]
            .str.split(' ')
            .apply(lambda l: ' '.join(l[:3]))
           )

    df_album_dates = (df_album_dates
                      .assign(Date=pd.to_datetime(s_dt))
                      .drop(columns='Album details')
                     )

    return df_album_dates

# Cell
@try_accept()
def name_2_album_meta(album, sp, artist=None):
    if artist is not None:
        query = f'{album} {artist}'
    else:
        query = album

    result = sp.search(query, type='album')
    s_first_album = pd.Series(result['albums']['items'][0])

    return s_first_album

# Cell
def check_release_date_consistency(df, s_first_album, album_name, td_val=150, td_units='days'):
    release_date_precision = pd.Timedelta(td_val, unit=td_units)

    assert isinstance(s_first_album, pd.Series), 's_first_album must be a Pandas series'
    release_date_sp = pd.to_datetime(s_first_album['release_date'])
    release_date_wiki = df.set_index('Title').loc[album_name, 'Date']

    release_delta = release_date_sp - release_date_wiki
    assert release_delta <= release_date_precision, f"The '{album_name}' release date on Spotify - {release_date_sp.date()}- and Wikipedia - {release_date_wiki.date()} - were inconsistent"

    return

# Cell
def df_album_dates_to_spotify_meta(df_album_dates):
    albums = dict()

    for album_name in df_album_dates['Title']:
        try:
            albums[album_name] = name_2_album_meta(album_name, sp, artist)
            check_release_date_consistency(df_album_dates, albums[album_name], album_name)
        except:
            albums.pop(album_name)
            warn(f'{album_name} could not be processed')

    df_albums_meta = pd.DataFrame(albums).T
    df_albums_meta.index.name = 'album_name'

    return df_albums_meta

# Cell
def extract_all_songs_in_albums(df_albums_meta):
    df_songs = pd.DataFrame()

    album_2_release_date = (df_albums_meta
                            ['release_date']
                            .apply(lambda dt: pd.to_datetime(dt).date())
                            .to_dict()
                           )

    for album_name in track(df_albums_meta.index):
        album_id = df_albums_meta.loc[album_name, 'id']
        album_uri = f'spotify:album:{album_id}'

        album_tracks = sp.album_tracks(album_uri)

        df_album_songs = pd.DataFrame(album_tracks['items'])[['uri', 'name', 'preview_url', 'track_number']]

        df_album_songs['album'] = album_name
        df_album_songs['album_release'] = album_2_release_date[album_name]

        df_songs = df_songs.append(df_album_songs)

    return df_songs

# Cell
def retrieve_track_analysis(df_songs, track_uri_col='uri', sp=None):
    if sp is None:
        sp = initialise_spotify_client()

    df_songs_analysis = pd.DataFrame()

    features_2_keep = ['danceability', 'energy', 'key', 'loudness', 'speechiness', 'acousticness',
                       'instrumentalness', 'liveness', 'valence', 'tempo', 'duration_ms', 'mode', 'time_signature']

    for track_idx, track_data in track(df_songs.iterrows(), total=df_songs.shape[0]):
        example_track_uri = track_data[track_uri_col]

        s_example_track_analysis = pd.Series(sp.audio_features(example_track_uri)[0])[features_2_keep]
        df_songs_analysis[track_idx] = s_example_track_analysis

    df_songs[df_songs_analysis.index] = df_songs_analysis.T

    return df_songs